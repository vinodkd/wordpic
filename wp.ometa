/*
ometa Wordpic {
   identifier = <string>,
   text = <string>,
   objname = identifier,
   instname = identifier,
   opr = ">" | "<",
   multicomment = "/*" text "\n"+ "*/",
   linecomment = "//" text "\n",
   comment = linecomment | multicomment,
   relation = instname opr instname [comment],
   objinst = instname ":" objname [comment]"\n",
   objdefbody = simplestatement*,
   simplestatement = objinst | relation | comment,
   objdef = "object" objname "{" objdefbody "}",
   statement = objdef | simplestatment,
   picbody = statement*,
   picture = "picture" picname:pn "{" picbody "}"

}

Wordpic.match('/* test
blah */','multicomment');

*/

// this works. see hard-earned-gyaan.txt

ometa WordpicScanner {
/**/
  wordpic = "picture" name:n "{" statements:s "}" -> [`wordpic,n,s],
  name = text,
  statements = statement+:s -> s,

  statement = objdef | simple_statement,
  objdef = "object" name:name "{" objdefbody:body "}" -> [`objectdef,name,body],
  simple_statement = name:o1 ( type_decl | rel_decl):suffix ->[suffix.op,o1,suffix.o2],

  objdefbody = simple_statement+,
  type_decl = ":" objtype:t -> {op:"typ",o2:t},
  rel_decl = opr:op name:o2 -> {op:op,o2:o2},
  objtype = "box" | "circle",
  opr = ">" | "<",

  text = spaces (qstring | nqstring):s ->s,
  space = ^space |fromTo('//','\n') | fromTo('/*','*/'), //this takes care of comments too. copied from bs-ometa-compiler.txt
  qstring = fromTo('"','"'),
  nqstring = letter+:ls -> (ls.join(''))
}

WordpicScanner.matchAll('picture "abc def" {
object blah {
  foo : box //test comment 
  c : circle
  bleh > foo
  /* another comment
   that spans lines
  */
} 
}','wordpic');
