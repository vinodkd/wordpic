/*
ometa Wordpic {
   identifier = <string>,
   text = <string>,
   objname = identifier,
   instname = identifier,
   opr = ">" | "<",
   multicomment = "/*" text "\n"+ "*/",
   linecomment = "//" text "\n",
   comment = linecomment | multicomment,
   relation = instname opr instname [comment],
   objinst = instname ":" objname [comment]"\n",
   objdefbody = simplestatement*,
   simplestatement = objinst | relation | comment,
   objdef = "object" objname "{" objdefbody "}",
   statement = objdef | simplestatment,
   picbody = statement*,
   picture = "picture" picname:pn "{" picbody "}"

}

Wordpic.match('/* test
blah */','multicomment');

*/

// this works. see hard-earned-gyaan.txt

ometa WordpicScanner {
/**/
  wordpic = "picture" name:n "{" statements:s "}" -> [`wordpic,n,s],
  name = text,
  statements = statement+:s -> s,

  statement = objdef | simple_statement,
  objdef = "object" name:name "{" objdefbody:body "}" -> [`objectdef,name,body],
  simple_statement = obj_decln | rel_decln,

  objdefbody = simple_statement+,
  obj_decln = name:obj ":" objtype:typ attrs?:attrs-> [`object, obj, typ, attrs],
  rel_decln = name:opd1 opr:op name:opd2 -> [op, opd1, opd2],
  objtype = "box" | "circle",
  attrs = "[" listOf('nvpair',","):a "]" -> a,

  opr = ">" | "<",
  nvpair = text,

  text = spaces (qstring | nqstring):s ->s,
  space = ^space |fromTo('//','\n') | fromTo('/*','*/'), //this takes care of comments too. copied from bs-ometa-compiler.txt
  qstring = fromTo('"','"'),
  nqstring = letterOrDigit+:ls -> (ls.join(''))
}
/*
WordpicScanner.matchAll("picture bleh {
object blah {
ab:box [attrs] // a comment
xy:circle
k > m
}
}",'wordpic');
*/
WordpicScanner.matchAll('ab:box [attrs]','simple_statement');
//WordpicScanner.matchAll('ab:box','simple_statement');
//WordpicScanner.matchAll('ab > cd','simple_statement');

WordpicScanner.matchAll("picture abc {
object blah {
  foo : box //test comment 
  c1 : circle [attr1,attr2] 
  bleh > foo
  /* another comment
   that spans lines
  */
} 
}",'wordpic');
